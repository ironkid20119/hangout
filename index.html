<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Poly's Weird Hangout</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #loginScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #loginScreen h1 {
            color: #00ff88;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }
        
        #loginScreen input {
            padding: 15px 25px;
            font-size: 1.2em;
            border: 2px solid #00ff88;
            background: #16213e;
            color: #fff;
            border-radius: 5px;
            margin-bottom: 15px;
            width: 300px;
            max-width: 90vw;
        }
        
        #loginScreen button {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #00ff88;
            color: #1a1a2e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #loginScreen button:hover {
            background: #00cc6a;
            transform: scale(1.05);
        }
        
        #chatContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 350px;
            background: rgba(22, 33, 62, 0.9);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 10px;
            display: none;
            z-index: 100;
        }
        
        #chatMessages {
            height: 120px;
            overflow-y: auto;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 12px;
        }
        
        #chatMessages div {
            color: #fff;
            margin-bottom: 4px;
            font-size: 12px;
        }
        
        #chatMessages .system {
            color: #00ff88;
            font-style: italic;
        }
        
        #chatInput {
            width: 100%;
            padding: 8px;
            background: #16213e;
            border: 1px solid #00ff88;
            color: #fff;
            border-radius: 5px;
            font-size: 12px;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            background: rgba(22, 33, 62, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
            display: none;
            z-index: 100;
            min-width: 150px;
        }
        
        #healthBar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff88);
            transition: width 0.3s;
            width: 100%;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 390px;
            color: #00ff88;
            background: rgba(22, 33, 62, 0.9);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #00ff88;
            display: none;
            font-size: 12px;
            z-index: 100;
        }

        #settings {
            position: absolute;
            top: 120px;
            right: 20px;
            color: #00ff88;
            background: rgba(22, 33, 62, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
            display: none;
            z-index: 100;
            min-width: 200px;
        }

        #settings label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        #settings input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        #lockPrompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 33, 62, 0.95);
            border: 2px solid #00ff88;
            padding: 20px 30px;
            border-radius: 8px;
            color: #00ff88;
            font-size: 16px;
            display: none;
            z-index: 200;
            text-align: center;
            cursor: pointer;
        }

        #lockPrompt:hover {
            background: rgba(22, 33, 62, 1);
            border-color: #00cc6a;
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            z-index: 100;
        }

        #joystick {
            width: 120px;
            height: 120px;
            background: rgba(22, 33, 62, 0.7);
            border: 3px solid #00ff88;
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        #joystickKnob {
            width: 50px;
            height: 50px;
            background: #00ff88;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #jumpButton {
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 136, 0.8);
            border: 3px solid #00ff88;
            border-radius: 50%;
            position: absolute;
            bottom: 140px;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a2e;
            font-weight: bold;
            font-size: 18px;
            touch-action: none;
            user-select: none;
        }

        #jumpButton:active {
            background: #00cc6a;
            transform: scale(0.95);
        }

        #shootButton {
            width: 80px;
            height: 80px;
            background: rgba(255, 107, 107, 0.8);
            border: 3px solid #ff6b6b;
            border-radius: 50%;
            position: absolute;
            bottom: 140px;
            left: 150px;
            display: none;
            align-items: center;
            justify-content: center;
            color: #1a1a2e;
            font-weight: bold;
            font-size: 18px;
            touch-action: none;
            user-select: none;
        }

        #shootButton:active {
            background: #ff4444;
            transform: scale(0.95);
        }

        #chatToggle {
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 136, 0.8);
            border: 3px solid #00ff88;
            border-radius: 50%;
            position: absolute;
            bottom: 140px;
            left: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            color: #1a1a2e;
            font-weight: bold;
            font-size: 20px;
            z-index: 100;
            touch-action: none;
        }

        @media (max-width: 768px) {
            #loginScreen h1 {
                font-size: 2em;
            }
            
            #controls, #settings {
                display: none !important;
            }

            #chatContainer {
                bottom: 90px;
                top: auto;
                left: 10px;
                width: calc(100vw - 20px);
            }

            #chatMessages {
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <div id="loginScreen">
        <h1>Poly's Weird Hangout</h1>
        <input type="text" id="usernameInput" placeholder="Enter your username" maxlength="15">
        <button id="joinButton">Join Hangout</button>
    </div>

    <div id="lockPrompt">
        Click anywhere to lock mouse
    </div>
    
    <div id="controls">
        <strong>Controls:</strong><br>
        WASD - Move<br>
        Mouse - Look around<br>
        Space - Jump<br>
        Enter - Chat<br>
        Left Click - Shoot (if you have gun)<br>
        ESC - Unlock mouse
    </div>
    
    <div id="info">
        Players: <span id="playerCount">1</span><br>
        <div id="healthBar">
            <div id="healthFill"></div>
        </div>
        HP: <span id="healthText">25/25</span>
    </div>

    <div id="settings">
        <strong>Settings</strong><br>
        <label>Mouse Sensitivity: <span id="sensValue">1.0</span></label>
        <input type="range" id="sensitivity" min="0.1" max="3.0" step="0.1" value="1.0">
    </div>
    
    <div id="chatContainer">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Press Enter to chat..." maxlength="100">
    </div>

    <div id="chatToggle">ðŸ’¬</div>

    <div id="mobileControls">
        <div id="jumpButton">JUMP</div>
        <div id="shootButton">SHOOT</div>
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        let scene, camera, renderer, ground;
        let localPlayer = null;
        let players = {};
        let aiEntities = [];
        let ws = null;
        let username = '';
        let moveState = { forward: false, backward: false, left: false, right: false };
        let chatActive = false;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Camera controls
        let cameraRotation = { x: 0, y: 0 };
        let cameraSensitivity = 1.0;
        let isPointerLocked = false;
        
        // Jump physics
        let isJumping = false;
        let jumpVelocity = 0;
        const gravity = 0.5;
        const jumpStrength = 10;

        // Mobile joystick
        let joystickActive = false;
        let joystickDirection = { x: 0, y: 0 };

        // Health system
        let health = 25;
        const maxHealth = 25;
        let damageImmunity = false;

        // Interactive objects
        let bouncePads = [];
        let collectibles = [];
        let speedZones = [];
        let gunPickup = null;

        // Gun system
        let hasGun = false;
        let gunAmmo = 3;
        const gunDamage = 12.5;
        const GUN_RESPAWN_TIME = 10000; // 10 seconds

        // AI spawn timer
        let lastAISpawn = Date.now();
        const AI_SPAWN_INTERVAL = 45000; // 45 seconds
        const AI_LIFETIME = 60000; // 1 minute

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Ground (100x100 inches)
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a8f5a,
                roughness: 0.8
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 20, 0x000000, 0x555555);
            scene.add(gridHelper);

            // Add interactive objects
            createBouncePads();
            createCollectibles();
            createSpeedZones();
            createGunPickup();

            window.addEventListener('resize', onWindowResize);
        }

        function createBouncePads() {
            const positions = [
                { x: -20, z: -20 },
                { x: 20, z: 20 },
                { x: -20, z: 20 },
                { x: 20, z: -20 }
            ];

            positions.forEach(pos => {
                const geometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xff6b6b,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.3
                });
                const pad = new THREE.Mesh(geometry, material);
                pad.position.set(pos.x, 0.25, pos.z);
                pad.castShadow = true;
                pad.userData = { type: 'bouncePad' };
                scene.add(pad);
                bouncePads.push(pad);
            });
        }

        function createCollectibles() {
            for (let i = 0; i < 10; i++) {
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                const collectible = new THREE.Mesh(geometry, material);
                collectible.position.set(
                    (Math.random() - 0.5) * 80,
                    0.5,
                    (Math.random() - 0.5) * 80
                );
                collectible.userData = { type: 'collectible', collected: false };
                scene.add(collectible);
                collectibles.push(collectible);
            }
        }

        function createSpeedZones() {
            const positions = [
                { x: 0, z: 30 },
                { x: 30, z: 0 },
                { x: -30, z: 0 }
            ];

            positions.forEach(pos => {
                const geometry = new THREE.CylinderGeometry(5, 5, 0.1, 32);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                const zone = new THREE.Mesh(geometry, material);
                zone.position.set(pos.x, 0.05, pos.z);
                zone.userData = { type: 'speedZone' };
                scene.add(zone);
                speedZones.push(zone);
            });
        }

        function createGunPickup() {
            // Gun body
            const bodyGeometry = new THREE.BoxGeometry(0.3, 0.3, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.8,
                roughness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);

            // Gun barrel
            const barrelGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.5);
            const barrel = new THREE.Mesh(barrelGeometry, bodyMaterial);
            barrel.position.z = 0.75;

            // Combine gun parts
            const gun = new THREE.Group();
            gun.add(body);
            gun.add(barrel);
            gun.rotation.x = Math.PI / 2;
            
            // Random position in world
            const randomX = (Math.random() - 0.5) * 80;
            const randomZ = (Math.random() - 0.5) * 80;
            gun.position.set(randomX, 0.5, randomZ);
            gun.userData = { type: 'gun', pickedUp: false };
            
            scene.add(gun);
            gunPickup = gun;
        }

        function respawnGun() {
            setTimeout(() => {
                createGunPickup();
                addChatMessage('Gun respawned on the map!', 'system');
            }, GUN_RESPAWN_TIME);
        }

        function shoot() {
            if (!hasGun || gunAmmo <= 0) return;

            gunAmmo--;
            updateGunDisplay();

            // Create bullet trace effect
            const bulletGeometry = new THREE.BufferGeometry();
            const bulletStart = new THREE.Vector3(
                localPlayer.mesh.position.x,
                localPlayer.mesh.position.y + 1.5,
                localPlayer.mesh.position.z
            );

            // Ray direction from camera
            const direction = new THREE.Vector3(
                Math.sin(cameraRotation.y),
                Math.sin(-cameraRotation.x),
                Math.cos(cameraRotation.y)
            ).normalize();

            const bulletEnd = bulletStart.clone().add(direction.multiplyScalar(100));

            bulletGeometry.setFromPoints([bulletStart, bulletEnd]);
            const bulletMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const bulletLine = new THREE.Line(bulletGeometry, bulletMaterial);
            scene.add(bulletLine);

            // Remove bullet trace after short delay
            setTimeout(() => scene.remove(bulletLine), 100);

            // Check for hits on players
            Object.values(players).forEach(player => {
                const playerPos = player.mesh.position;
                const toPlayer = new THREE.Vector3().subVectors(playerPos, bulletStart);
                const dist = toPlayer.length();
                
                if (dist < 100) {
                    const angle = direction.angleTo(toPlayer);
                    if (angle < 0.1) { // Hit detection cone
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'damage',
                                targetId: player.id,
                                damage: gunDamage
                            }));
                        }
                        addChatMessage(`Hit ${player.name}!`, 'system');
                    }
                }
            });

            // Check for hits on AI
            aiEntities.forEach((ai, index) => {
                const aiPos = ai.mesh.position;
                const toAI = new THREE.Vector3().subVectors(aiPos, bulletStart);
                const dist = toAI.length();
                
                if (dist < 100) {
                    const angle = direction.angleTo(toAI);
                    if (angle < 0.1) {
                        scene.remove(ai.mesh);
                        aiEntities.splice(index, 1);
                        addChatMessage('Hit AI!', 'system');
                    }
                }
            });

            if (gunAmmo === 0) {
                addChatMessage('Gun empty!', 'system');
            }
        }

        function updateGunDisplay() {
            if (hasGun) {
                document.getElementById('healthText').textContent = `${health}/${maxHealth} | Ammo: ${gunAmmo}/3`;
            } else {
                document.getElementById('healthText').textContent = `${health}/${maxHealth}`;
            }
        }

        // Create AI entity
        function spawnAI() {
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 0.3
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.position.set(
                (Math.random() - 0.5) * 80,
                1,
                (Math.random() - 0.5) * 80
            );
            
            scene.add(cube);

            // Add AI label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#ff00ff';
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.fillText('AI', 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 1, 1);
            sprite.position.y = 2.5;
            cube.add(sprite);

            const ai = {
                mesh: cube,
                velocity: new THREE.Vector3(),
                jumpVelocity: 0,
                isJumping: false,
                spawnTime: Date.now(),
                direction: Math.random() * Math.PI * 2,
                nextJump: Date.now() + Math.random() * 3000,
                nextDirectionChange: Date.now() + Math.random() * 2000 + 1000
            };

            aiEntities.push(ai);
        }

        function updateAI() {
            const now = Date.now();
            
            // Spawn new AI
            if (now - lastAISpawn > AI_SPAWN_INTERVAL) {
                spawnAI();
                lastAISpawn = now;
            }

            // Update existing AI
            aiEntities.forEach((ai, index) => {
                // Check lifetime
                if (now - ai.spawnTime > AI_LIFETIME) {
                    scene.remove(ai.mesh);
                    aiEntities.splice(index, 1);
                    return;
                }

                // Change direction randomly
                if (now > ai.nextDirectionChange) {
                    ai.direction = Math.random() * Math.PI * 2;
                    ai.nextDirectionChange = now + Math.random() * 2000 + 1000;
                }

                // Random jumping
                if (now > ai.nextJump && !ai.isJumping) {
                    ai.isJumping = true;
                    ai.jumpVelocity = jumpStrength;
                    ai.nextJump = now + Math.random() * 3000 + 2000;
                }

                // Movement
                const speed = 0.15;
                ai.mesh.position.x += Math.sin(ai.direction) * speed;
                ai.mesh.position.z += Math.cos(ai.direction) * speed;

                // Jump physics
                if (ai.isJumping) {
                    ai.mesh.position.y += ai.jumpVelocity * 0.1;
                    ai.jumpVelocity -= gravity;
                    
                    if (ai.mesh.position.y <= 1) {
                        ai.mesh.position.y = 1;
                        ai.isJumping = false;
                        ai.jumpVelocity = 0;
                    }
                }

                // Boundary checking
                ai.mesh.position.x = Math.max(-50, Math.min(50, ai.mesh.position.x));
                ai.mesh.position.z = Math.max(-50, Math.min(50, ai.mesh.position.z));

                // Collision with player
                const collisionDist = 2 * localPlayer.scale;
                const distance = localPlayer.mesh.position.distanceTo(ai.mesh.position);
                if (distance < collisionDist && !damageImmunity) {
                    takeDamage(5);
                    damageImmunity = true;
                    setTimeout(() => damageImmunity = false, 1000);
                }
            });
        }

        // Create player cube
        function createPlayer(id, name, color) {
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.position.y = 1;
            
            // Random spawn position
            cube.position.x = (Math.random() - 0.5) * 80;
            cube.position.z = (Math.random() - 0.5) * 80;
            
            // 1/5 chance for size variation
            let playerScale = 1;
            const sizeRoll = Math.random();
            if (sizeRoll < 0.1) { // 10% chance to be 2x bigger
                playerScale = 2;
                cube.scale.set(2, 2, 2);
                cube.position.y = 2; // Adjust height
            } else if (sizeRoll < 0.2) { // 10% chance to be 2x smaller
                playerScale = 0.5;
                cube.scale.set(0.5, 0.5, 0.5);
                cube.position.y = 0.5; // Adjust height
            }
            
            scene.add(cube);

            // Name label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#00ff88';
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.fillText(name, 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 1, 1);
            sprite.position.y = 2.5;
            cube.add(sprite);

            return {
                mesh: cube,
                velocity: new THREE.Vector3(),
                id: id,
                name: name,
                health: maxHealth,
                scale: playerScale
            };
        }

        // Handle login
        document.getElementById('joinButton').addEventListener('click', () => {
            username = document.getElementById('usernameInput').value.trim();
            if (username.length > 0) {
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('chatContainer').style.display = 'block';
                document.getElementById('info').style.display = 'block';
                document.getElementById('settings').style.display = 'block';
                
                if (!isMobile) {
                    document.getElementById('controls').style.display = 'block';
                    document.getElementById('lockPrompt').style.display = 'block';
                } else {
                    document.getElementById('mobileControls').style.display = 'block';
                    document.getElementById('chatToggle').style.display = 'flex';
                }
                
                startGame();
            }
        });

        document.getElementById('usernameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('joinButton').click();
            }
        });

        function startGame() {
            initScene();
            
            // Create local player
            const randomColor = Math.random() * 0xffffff;
            localPlayer = createPlayer('local', username, randomColor);
            cameraRotation.y = Math.PI;

            setupControls();
            connectWebSocket();
            animate();
            
            addChatMessage('Welcome to Poly\'s Weird Hangout!', 'system');
            addChatMessage(isMobile ? 'Use joystick to move!' : 'Click to lock mouse and look around!', 'system');
            addChatMessage('Gun spawns randomly and respawns every 10 seconds!', 'system');
            
            // Notify if player has special size
            if (localPlayer.scale === 2) {
                addChatMessage('You are GIANT size! (2x bigger)', 'system');
            } else if (localPlayer.scale === 0.5) {
                addChatMessage('You are TINY size! (2x smaller)', 'system');
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            const serverUrl = 'ws://localhost:3000';
            
            try {
                ws = new WebSocket(serverUrl);
                
                ws.onopen = () => {
                    addChatMessage('Connected to server!', 'system');
                    ws.send(JSON.stringify({
                        type: 'join',
                        username: username,
                        color: localPlayer.mesh.material.color.getHex(),
                        position: localPlayer.mesh.position
                    }));
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleServerMessage(data);
                };

                ws.onerror = () => {
                    addChatMessage('Running in offline mode', 'system');
                };

                ws.onclose = () => {
                    addChatMessage('Disconnected from server', 'system');
                };
            } catch (error) {
                addChatMessage('Running in offline mode', 'system');
            }
        }

        function handleServerMessage(data) {
            switch(data.type) {
                case 'playerJoined':
                    if (data.id !== 'local') {
                        players[data.id] = createPlayer(data.id, data.username, data.color);
                        players[data.id].mesh.position.copy(data.position);
                        addChatMessage(`${data.username} joined the hangout`, 'system');
                        updatePlayerCount();
                    }
                    break;
                    
                case 'playerLeft':
                    if (players[data.id]) {
                        scene.remove(players[data.id].mesh);
                        addChatMessage(`${players[data.id].name} left the hangout`, 'system');
                        delete players[data.id];
                        updatePlayerCount();
                    }
                    break;
                    
                case 'playerMove':
                    if (players[data.id]) {
                        players[data.id].mesh.position.copy(data.position);
                    }
                    break;
                    
                case 'chat':
                    addChatMessage(`${data.username}: ${data.message}`);
                    break;
                    
                case 'players':
                    data.players.forEach(player => {
                        if (player.id !== 'local' && !players[player.id]) {
                            players[player.id] = createPlayer(player.id, player.username, player.color);
                            players[player.id].mesh.position.copy(player.position);
                        }
                    });
                    updatePlayerCount();
                    break;
            }
        }

        function setupControls() {
            // Sensitivity slider
            document.getElementById('sensitivity').addEventListener('input', (e) => {
                cameraSensitivity = parseFloat(e.target.value);
                document.getElementById('sensValue').textContent = cameraSensitivity.toFixed(1);
            });

            // Pointer lock for PC
            if (!isMobile) {
                const requestPointerLock = () => {
                    if (!chatActive && !isPointerLocked) {
                        renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                            renderer.domElement.mozRequestPointerLock ||
                            renderer.domElement.webkitRequestPointerLock;
                        renderer.domElement.requestPointerLock();
                    }
                };

                // Click on canvas or prompt to lock
                renderer.domElement.addEventListener('click', requestPointerLock);
                document.getElementById('lockPrompt').addEventListener('click', requestPointerLock);
                document.body.addEventListener('click', requestPointerLock);

                const pointerLockChange = () => {
                    isPointerLocked = !!(document.pointerLockElement || 
                                        document.mozPointerLockElement || 
                                        document.webkitPointerLockElement);
                    document.getElementById('lockPrompt').style.display = isPointerLocked ? 'none' : 'block';
                };

                document.addEventListener('pointerlockchange', pointerLockChange);
                document.addEventListener('mozpointerlockchange', pointerLockChange);
                document.addEventListener('webkitpointerlockchange', pointerLockChange);

                document.addEventListener('mousemove', (e) => {
                    if (isPointerLocked && !chatActive) {
                        const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                        const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
                        
                        cameraRotation.y -= movementX * 0.002 * cameraSensitivity;
                        cameraRotation.x -= movementY * 0.002 * cameraSensitivity;
                        cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x));
                    }
                });

                // Shooting with left click
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0 && isPointerLocked && !chatActive && hasGun && gunAmmo > 0) {
                        shoot();
                    }
                });
            }

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (chatActive) return;
                
                switch(e.key.toLowerCase()) {
                    case 'w': moveState.forward = true; break;
                    case 's': moveState.backward = true; break;
                    case 'a': moveState.left = true; break;
                    case 'd': moveState.right = true; break;
                    case ' ':
                        e.preventDefault();
                        jump();
                        break;
                    case 'enter':
                        e.preventDefault();
                        document.getElementById('chatInput').focus();
                        chatActive = true;
                        if (isPointerLocked) {
                            document.exitPointerLock();
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': moveState.forward = false; break;
                    case 's': moveState.backward = false; break;
                    case 'a': moveState.left = false; break;
                    case 'd': moveState.right = false; break;
                }
            });

            // Touch camera controls for mobile
            if (isMobile) {
                let touchStartPos = null;
                renderer.domElement.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1 && !chatActive) {
                        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                });

                renderer.domElement.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && touchStartPos && !chatActive) {
                        const deltaX = e.touches[0].clientX - touchStartPos.x;
                        const deltaY = e.touches[0].clientY - touchStartPos.y;
                        
                        cameraRotation.y -= deltaX * 0.005 * cameraSensitivity;
                        cameraRotation.x -= deltaY * 0.005 * cameraSensitivity;
                        cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x));
                        
                        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                });

                renderer.domElement.addEventListener('touchend', () => {
                    touchStartPos = null;
                });

                // Mobile joystick
                const joystick = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystickKnob');

                function handleJoystickMove(clientX, clientY) {
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let deltaX = clientX - centerX;
                    let deltaY = clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 25;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        deltaX = Math.cos(angle) * maxDistance;
                        deltaY = Math.sin(angle) * maxDistance;
                    }
                    
                    joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                    
                    joystickDirection.x = deltaX / maxDistance;
                    joystickDirection.y = deltaY / maxDistance;
                }

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickActive = true;
                    handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
                });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (joystickActive) {
                        handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
                    }
                });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                    joystickDirection = { x: 0, y: 0 };
                });

                // Jump button
                document.getElementById('jumpButton').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    jump();
                });

                // Shoot button
                document.getElementById('shootButton').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (hasGun && gunAmmo > 0) {
                        shoot();
                    }
                });

                // Chat toggle for mobile
                document.getElementById('chatToggle').addEventListener('click', () => {
                    const chatContainer = document.getElementById('chatContainer');
                    chatContainer.style.display = chatContainer.style.display === 'none' ? 'block' : 'none';
                });
            }

            // Chat input
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const message = e.target.value.trim();
                    if (message) {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'chat',
                                message: message
                            }));
                        } else {
                            // Offline mode - show message locally
                            addChatMessage(`${username}: ${message}`);
                        }
                    }
                    e.target.value = '';
                    e.target.blur();
                    chatActive = false;
                }
            });

            document.getElementById('chatInput').addEventListener('focus', () => {
                chatActive = true;
            });

            document.getElementById('chatInput').addEventListener('blur', () => {
                chatActive = false;
            });
        }

        function jump() {
            if (!isJumping) {
                isJumping = true;
                jumpVelocity = jumpStrength;
            }
        }

        function checkCollisions() {
            const playerSize = localPlayer.scale;
            
            // Check player collisions
            Object.values(players).forEach(player => {
                const collisionDist = (1 + (player.scale || 1)) * playerSize;
                const distance = localPlayer.mesh.position.distanceTo(player.mesh.position);
                if (distance < collisionDist && !damageImmunity) {
                    takeDamage(5);
                    damageImmunity = true;
                    setTimeout(() => damageImmunity = false, 1000);
                }
            });

            // Check bounce pads
            bouncePads.forEach(pad => {
                const distance = localPlayer.mesh.position.distanceTo(pad.position);
                if (distance < 3.5 && !isJumping) {
                    jumpVelocity = jumpStrength * 2;
                    isJumping = true;
                }
            });

            // Check collectibles
            collectibles.forEach(collectible => {
                if (!collectible.userData.collected) {
                    const pickupDist = 1.5 * playerSize;
                    const distance = localPlayer.mesh.position.distanceTo(collectible.position);
                    if (distance < pickupDist) {
                        collectible.userData.collected = true;
                        scene.remove(collectible);
                        health = Math.min(maxHealth, health + 5);
                        updateHealth();
                    }
                }
            });

            // Animate collectibles
            collectibles.forEach(collectible => {
                if (!collectible.userData.collected) {
                    collectible.rotation.y += 0.05;
                    collectible.position.y = 0.5 + Math.sin(Date.now() * 0.003) * 0.3;
                }
            });

            // Check gun pickup
            if (gunPickup && !gunPickup.userData.pickedUp) {
                gunPickup.rotation.y += 0.02;
                const pickupDistance = 2 * localPlayer.scale; // Adjust for player size
                const distance = localPlayer.mesh.position.distanceTo(gunPickup.position);
                if (distance < pickupDistance) {
                    gunPickup.userData.pickedUp = true;
                    scene.remove(gunPickup);
                    hasGun = true;
                    gunAmmo = 3;
                    updateGunDisplay();
                    addChatMessage('Picked up gun! (3 shots, 12.5 damage)', 'system');
                    if (isMobile) {
                        document.getElementById('shootButton').style.display = 'flex';
                        addChatMessage('Tap SHOOT button to fire!', 'system');
                    } else {
                        addChatMessage('Left click to shoot!', 'system');
                    }
                    respawnGun();
                }
            }
        }

        function takeDamage(amount) {
            health = Math.max(0, health - amount);
            updateHealth();
            
            if (health === 0) {
                addChatMessage('You died! Respawning...', 'system');
                respawn();
            }
        }

        function respawn() {
            health = maxHealth;
            updateHealth();
            const respawnY = localPlayer.scale === 2 ? 2 : (localPlayer.scale === 0.5 ? 0.5 : 1);
            localPlayer.mesh.position.set(
                (Math.random() - 0.5) * 80,
                respawnY,
                (Math.random() - 0.5) * 80
            );
            damageImmunity = true;
            setTimeout(() => damageImmunity = false, 3000);
        }

        function updateHealth() {
            const percentage = (health / maxHealth) * 100;
            document.getElementById('healthFill').style.width = percentage + '%';
            updateGunDisplay();
        }

        function updatePlayer() {
            const baseSpeed = 0.2;
            let speed = baseSpeed;
            
            // Check if in speed zone
            speedZones.forEach(zone => {
                const distance = localPlayer.mesh.position.distanceTo(zone.position);
                if (distance < 5) {
                    speed = baseSpeed * 2;
                }
            });

            const direction = new THREE.Vector3();

            // Handle keyboard or joystick input
            if (isMobile && joystickActive) {
                const forward = new THREE.Vector3(
                    Math.sin(cameraRotation.y),
                    0,
                    Math.cos(cameraRotation.y)
                ).normalize();
                
                const right = new THREE.Vector3(
                    Math.sin(cameraRotation.y + Math.PI / 2),
                    0,
                    Math.cos(cameraRotation.y + Math.PI / 2)
                ).normalize();

                direction.add(forward.multiplyScalar(-joystickDirection.y * speed));
                direction.add(right.multiplyScalar(joystickDirection.x * speed));
            } else {
                const forward = new THREE.Vector3(
                    Math.sin(cameraRotation.y),
                    0,
                    Math.cos(cameraRotation.y)
                ).normalize();
                
                const right = new THREE.Vector3(
                    Math.sin(cameraRotation.y + Math.PI / 2),
                    0,
                    Math.cos(cameraRotation.y + Math.PI / 2)
                ).normalize();

                if (moveState.forward) direction.add(forward.multiplyScalar(speed));
                if (moveState.backward) direction.add(forward.multiplyScalar(-speed));
                if (moveState.left) direction.add(right.multiplyScalar(speed));
                if (moveState.right) direction.add(right.multiplyScalar(-speed));
            }

            localPlayer.mesh.position.add(direction);

            // Jump physics
            if (isJumping) {
                localPlayer.mesh.position.y += jumpVelocity * 0.1;
                jumpVelocity -= gravity;
                
                if (localPlayer.mesh.position.y <= 1) {
                    localPlayer.mesh.position.y = 1;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }

            // Boundary checking
            localPlayer.mesh.position.x = Math.max(-50, Math.min(50, localPlayer.mesh.position.x));
            localPlayer.mesh.position.z = Math.max(-50, Math.min(50, localPlayer.mesh.position.z));

            // Update camera position and rotation
            const cameraDistance = 10 * localPlayer.scale;
            const cameraHeight = 5 * localPlayer.scale;
            
            camera.position.x = localPlayer.mesh.position.x - Math.sin(cameraRotation.y) * cameraDistance;
            camera.position.z = localPlayer.mesh.position.z - Math.cos(cameraRotation.y) * cameraDistance;
            camera.position.y = localPlayer.mesh.position.y + cameraHeight + Math.sin(cameraRotation.x) * 5;
            
            camera.lookAt(
                localPlayer.mesh.position.x,
                localPlayer.mesh.position.y + localPlayer.scale,
                localPlayer.mesh.position.z
            );

            // Check collisions
            checkCollisions();

            // Update AI
            updateAI();

            // Send position to server
            if (ws && ws.readyState === WebSocket.OPEN && (direction.length() > 0 || isJumping)) {
                ws.send(JSON.stringify({
                    type: 'move',
                    position: localPlayer.mesh.position
                }));
            }
        }

        function addChatMessage(message, type = 'normal') {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function updatePlayerCount() {
            document.getElementById('playerCount').textContent = Object.keys(players).length + 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
